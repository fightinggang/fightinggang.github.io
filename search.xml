<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Next 主题美化]]></title>
    <url>%2F2018%2F06%2F25%2FNext-%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[换上简洁大气的 Next 主题后，总要折腾一番才符合 猿 的气质。 站内搜索原文地址：Local-search 安装 hexo-generator-searchdb，在 blog 根目录下执行命令： 1$ npm install hexo-generator-searchdb --save 编辑 blog 目录下的配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 重新构建就可以看到效果 字数统计参照 hexo-symbols-count-time Next 内置标签居中引用123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;&lt;blockquote class="blockquote-center"&gt; Content &lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125; Content &#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; Content &#123;% endcq %&#125; 效果：横眉冷对千夫指，俯首甘为孺子牛。–鲁迅 彩色引用块 1&#123;% note className %&#125; 内容块 &#123;% endnote %&#125; className 可以为：default primary success info warning danger 效果：success markdown 默认]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新开始]]></title>
    <url>%2F2018%2F06%2F24%2F%E6%96%B0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[​ 自从 2016 年搭建好博客后，断断续续的写了几篇博客后，这个博客就停更了！！！​ 原因有很多，最重要的可能还是惰性与自卑吧！觉得技术一般没什么可以分享的，然后就搁置了。 转眼间到了 2018 年，来到了武汉，经历过许多事情，也应该给自己一个改变。就像漫威宇宙重启一样，我也要重启我的博客，抛弃必要时的不自卑与非必要时的自负，做一个谦虚扎实的人！ 定一个小目标：每周记录至少更新一篇技术博客！共勉！ PS: 2018 年才完成了 2016 年的一个小目标，注册一个公众号，去维护它。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次啼笑皆非的操作]]></title>
    <url>%2F2018%2F02%2F28%2F%E4%B8%80%E6%AC%A1%E5%95%BC%E7%AC%91%E7%9A%86%E9%9D%9E%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简单的东西配置下，希望让操作方便些，没想到却造成了一次啼笑皆非的操作。 起因每次用默认的用户切换 root 权限，sudo su - 都要输入密码，不免麻烦，于是去网络的世界中找找 去掉免输密码的方式。 修改方式： 切换到 root，sudo su - (注意有- ，这和su是不同的，在用命令”su”的时候只是切换到root，但没有把root的环境变量传过去，还是当前用乎的环境变量，用”su -“命令将环境变量也一起带过去，就象和root登录一样) visudo 或者 vim /etc/sudoers，查看文中的注释。移动光标，到一行root ALL=(ALL) ALL的下一行，按a，进入append模式，输入 1your_user_name ALL=(ALL) ALL 保存，退出。这样就把自己加入了sudo组，可以使用sudo命令了。 默认5分钟后刚才输入的 sodo 密码过期，下次sudo需要重新输入密码，如果觉得在sudo的时候输入密码麻烦，把刚才的输入换成如下内容即可： 1your_user_name ALL=(ALL) NOPASSWD: ALL 这样，每次 sudo su - 的时候就不用再输入密码了。 问题-乌龙的过程问题就出再修改之后，退出 root ，使用普通用户 sudo su -，报语法错误。 1234&gt;&gt;&gt; /etc/sudoers: 语法错误 near line 21 &lt;&lt;&lt;sudo: /etc/sudoers 中第 21 行附近有解析错误sudo: 没有找到有效的 sudoers 资源，退出sudo: 无法初始化策略插件 这下就很尴尬了，目前只有一个用户，切换不到 root ，不能修改也不能也没法添加用户了。 尝试了网上的多种方式，有重启进入 grub ，然后在进入 recovery 模式的，不行。 后来，还是找到了最靠谱的一种方式： 1pkexec visudo 输入完，需要输入密码，然后就可以修改文件了。看到了错误的原因是 your_user_name ALL=(ALL) NOPASSWORD: ALL（password 应该是 PASSWD）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis批量操作]]></title>
    <url>%2F2016%2F12%2F14%2FMybatis%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在项目开发的过程中，一般的操作都是单条数据操作，插入一次提交一次事务；但是往往会有大批量类似的数据需要插入，此时用循环单条插入的方式去操作也可以，但是频繁的请求数据库资源很耗费系统资源，有没有更好的方式呢？ 发现问题后就要尝试查找资料去解决问题，去看 MyBatis 的源码？一大堆不知道从那看起？那就去看Github。众多周知， Mybatis 源码等相关信息是托管在 Github 上的，可以看看他的 wiki 里有没有相应的方案，在它的 FAQ(Frequently Asked Questions)的中有关于批量插入的示例：首先，创建一个简单的插入语句： &lt;insert id=&quot;insertName&quot;&gt; insert into names (name) values (#{value}) &lt;/insert&gt; 然后在 Java 代码中执行批量操作: List&lt;String&gt; names = new ArrayList&lt;String&gt;(); names.add(&quot;Fred&quot;); names.add(&quot;Barney&quot;); names.add(&quot;Betty&quot;); names.add(&quot;Wilma&quot;); SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { NameMapper mapper = sqlSession.getMapper(NameMapper.class); for (String name : names) { mapper.insertName(name); } sqlSession.commit(); } finally { sqlSession.close(); } 示例中的操作是 insert，同理 update、delete 等的操作也一样，要点是事务提交一次。 目前的数据库有多种，各个数据库批量插入的方式不一样，但是对于单条插入然后去循环的方式是都支持的，所以 MyBatis 做了一个共通的实例，将执行类型设置ExecutorType.BATCH,批量去提交事务。 示例中的核心在于创建一个操作批量事物的SqlSession，在纯 MyBatis 中 SqlSession 的获取方式为： InputStream in=Resources.getResourceAsStream(&quot;applicationContext.xml&quot;); SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(in); SqlSession sqlsession=factory.openSession(); 查看 Mybatis 中可看到默创建的事务为简单事务： ExecutorType.SIMPLE，批量插入要修改事务类型。 Java 程序处理在后续的开发中，MyBatis 常与其他框架一起使用，最常见的是 SSM(Spring+SpringMVC+Mybatis) 的整合，通常对数据库事务的操作就交给Spring 去处理了。此时如果有大量数据需要插入，利用循环去 mapper.inset(entity) 也可以解决问题，但是每执行一次都需要开启一个新的事务，对资源的消耗比较大。所以，要采用其他的更优化的方案。 在 Spring 中不用关心 SqlSession 是如何创建销毁的，在applicationContext.xml中配置响应的 SqlsessionFactory 即可。 &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt; &lt;/bean&gt; 如果要在 Java 中去控制事务类型，可通过注入 SqlSeesionFactory 的方式显示的获取 SqlSession， @Autowired private SqlSessionFactoryBean sqlSessionFactory; …… SqlSession sqlSession=sqlSessionFactory.getObject().openSession(ExecutorType.BATCH); 获取到 SqlSession 之后在仿照示例中的代码写就可以了。 SQL 拼接处理另一种方式是通过动态拼接 SQL 的形式去批量插入，这是的主要工作是在数据库那一端进行的。各个数据库批量插入的方式不一样，以下举最常见的两个数据库 MySQL 与 Oracle，其他的数据库欢迎补充。 Dao 中的代码： public interface userDao{ public void insertBatch(@Param(&quot;userList&quot;) List userList); } MySQLMySQL 支持如下类型的 SQL 语句： insert into users(username,age) values(&apos;zhangsan&apos;，18),(&apos;liming&apos;,20),(&apos;fengyu&apos;,23); 上述 SQL 是 MySQL 特有的，可在*.xml 文件中去执行拼接， &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;java.util.List&quot;&gt; insert into users(username,age) values &lt;foreach collection=&quot;userList&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; (#{item.username},#{item.age}) &lt;/foreach&gt; &lt;/insert&gt; OracleOracle 不支持 MySQL 那种写法，但是他也有自己的其他语句来实现这样的功能： Oracle 中可以使用 insert all，insert first ，union all 等语句去执行批量的事务操作。 union all： &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;java.util.List&quot;&gt; insert into users(username,age) &lt;foreach collection=&quot;freeNumberList&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;union all&quot;&gt; select #{item.username},#{item.age} from dual &lt;/foreach&gt; &lt;/insert&gt; insert all： &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;java.util.List&quot;&gt; insert all &lt;foreach collection=&quot;freeNumberList&quot; item=&quot;item&quot; index=&quot;index&quot;&gt; into users(username,age) values(#{item.username},#{item.age}) &lt;/foreach&gt; select 1 from dual &lt;/insert&gt; insert first 与 insert all 区别在于insert all 只要符合条件就都插入，insert first有一个条件判断，可以在 sql 中加上 where 条件。 具体使用是使用 Java 代码的方式，还是使用 SQL 拼接的方式，要根据具体的项目定了。 目前还没有做关于这两种方式的批量插入的效率问题，后续再补。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try catch finally分析]]></title>
    <url>%2F2016%2F08%2F22%2Ftry-catch-finally%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[​ 最近在看Java基础，隔了好长一段时间不去接触底层的东西，好多东西就在念念不忘中忘记了，现在要重新拾起来，看的书是《Think in Java》。越看越觉得一些细微的点自己以前没有注意到，幸好这个时候看了书，要不然永远也不会记起来了。 ​ 写此篇Blog并不是为了分享读书的新的，而是最近在刷脉脉的时候看到了一个很有去的题目，匿名区好多人讨论。 题目是输出一段代码的运行结果，代码是： 1234567891011// main方法public static void main(String[] args) &#123; System.out.println(convert("a"));&#125; public static String convert(String str) &#123; try &#123; return str; &#125; finally &#123; str.toUpperCase(); &#125; &#125; 最后程序运行的结果是:a (笔者自己本地运行测试了，确实是a)。这是很容易错的一个问题，因为一般大家会想到最后输出的是A。这就需要了解try-catch-finallly的运行机制。一个简单的例子(例1)：1234567891011121314151617public class TryCatchFinally &#123; public static final String test() &#123; String t = ""; try &#123; t = "try"; return t; &#125; catch (Exception e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; &#125; &#125; public static void main(String[] args) &#123; System.out.print(TryCatchFinally.test()); &#125;&#125; 有了第一个例子，这个例子输出的结果肯定的 “try”。 为什么会这样，我们不妨先看看这段代码编译出来的class对应的字节码，看虚拟机内部是如何执行的。 我们用javap -verbose TryCatchFinally 来显示目标文件(.class文件)字节码信息. 12345系统运行环境： windows10 64bitJDK基本信息： java version "1.8.0_91" Java(TM) SE Runtime Environment (build 1.8.0_91-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode) .class 文件的信息: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static final java.lang.String test(); descriptor: ()Ljava/lang/String; flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL Code: stack=1, locals=4, args_size=0 0: ldc #16 // String 2: astore_0 3: ldc #18 // String try 5: astore_0 6: aload_0 7: astore_3 8: ldc #20 // String finally 10: astore_0 11: aload_3 12: areturn 13: astore_1 14: ldc #22 // String catch 16: astore_0 17: aload_0 18: astore_3 19: ldc #20 // String finally 21: astore_0 22: aload_3 23: areturn 24: astore_2 25: ldc #20 // String finally 27: astore_0 28: aload_2 29: athrow Exception table: from to target type 3 8 13 Class java/lang/Exception 3 8 24 any 13 19 24 any LineNumberTable: line 5: 0 line 8: 3 line 9: 6 line 15: 8 line 9: 11 line 10: 13 line 12: 14 line 13: 17 line 15: 19 line 13: 22 line 14: 24 line 15: 25 line 16: 28 LocalVariableTable: Start Length Slot Name Signature 3 27 0 t Ljava/lang/String; 14 10 1 e Ljava/lang/Exception; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 13 locals = [ class java/lang/String ] stack = [ class java/lang/Exception ] frame_type = 74 /* same_locals_1_stack_item */ stack = [ class java/lang/Throwable ]SourceFile: "TryCatchFinally.java" 从以上文件可以看出： 首先看LocalVariableTable信息，这里面定义了两个变量 一个是t String类型,一个是e Exception 类型接下来看Code部分第[0-2]行，给第0个变量赋值””，也就是String t=””；第[3-6]行，也就是执行try语句块 赋值语句 ，也就是 t = “try”;第7行，重点是第7行，把第s对应的值”try”付给第三个变量；第[8-10] 行，对第0个变量进行赋值操作，也就是t=”finally”第[11-12]行，把第三个变量对应的值返回。通过字节码，我们发现，在try语句的return块中，return 返回的引用变量（t 是引用类型）并不是try语句外定义的引用变量t，而是系统重新定义了一个局部引用t’，这个引用指向了引用t对应的值，也就是try ，即使在finally语句中把引用t指向了值finally，因为return的返回引用已经不是t ，所以引用t的对应的值和try语句中的返回值无关了。 ​ –引用java中关于try、catch、finally中的细节分析 假若将上述例子加以修改(例2)： 12345678910111213141516171819public class TryCatchFinally &#123; @SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; return t; &#125; catch (Exception e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; return t; &#125; &#125; public static void main(String[] args) &#123; System.out.print(test()); // 在当前类调用可不加类名 &#125;&#125; 则最后输出的结果为：”finallly”。 例3 try抛出异常,finally无返回： 1234567891011121314public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; e.printStackTrace(); t = "catch"; return t; &#125; finally &#123; t = "finally"; &#125;&#125; 此时，解析异常，会抛出java.lang.NumberFormatException: null的异常，从try语句中的Integer.parseInt(null);直接跳转到catch语句中运行，t赋值为catch， 在执行return之前，会把返回值保存到一个临时变量里面t ‘，执行finally的逻辑，t赋值为finally，但是返回值和t’，所以变量t的值和返回值已经没有关系了，返回的是catch 例4 try抛出异常,finally有返回： 12345678910111213141516 @SuppressWarnings("finally")public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; e.printStackTrace(); t = "catch"; return t; &#125; finally &#123; t = "finally"; return t; &#125;&#125; 由于try语句里面抛出异常，程序转入catch语句块，catch语句在执行return语句之前执行finally，而finally语句有return,则直接执行finally的语句值，返回finally. 例5 try catch抛出异常,finally无返回： 1234567891011121314public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; t = "catch"; Integer.parseInt(null); return t; &#125; finally &#123; t = "finally"; &#125;&#125; try异常—&gt;catch—&gt;catch异常 —&gt;执行finally语句块，对t进行赋值.结果是抛出java.lang.NumberFormatException异常. 例6 try catch抛出异常,finally有返回：123456789101112131415public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; t = "catch"; Integer.parseInt(null); return t; &#125; finally &#123; t = "finally"; return t; &#125;&#125; 这个例子里面finally 语句里面有return语句块。try catch中运行的逻辑和上面例子一样，当catch语句块里面抛出异常之后，进入finally语句快，然后返回t。则程序忽略catch语句块里面抛出的异常信息，直接返回t对应的值 finally。 例7 捕获NullPointer异常： 12345678910111213public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (NullPointerException e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; &#125; &#125; try语句中抛出异常，进入到catch语句中，catch的是NullPointerException，而抛出的是NumberFormatException，直接进入finally语句块，finally对t赋值之后，由try语句抛出java.lang.NumberFormatException异常。 例8 捕获异常： 123456789101112131415@SuppressWarnings("finally")public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (NumberFormatException e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; return t; &#125;&#125; 最后结果是 finally 例9 多重异常： 12345678910111213141516@SuppressWarnings("finally") public static final String test() &#123; String t = ""; try &#123; t = "try"; Integer.parseInt(null); return t; &#125; catch (Exception e) &#123; t = "catch"; return t; &#125; finally &#123; t = "finally"; Integer.parseInt(null); return t; &#125; &#125; 首先程序执行try语句，异常后进入catch语句执行，在返回执行执行finally语句块，finally语句抛出NumberFormatException异常，整个结果返回NumberFormatException异常。 总结: try、catch、finally语句中，若try中有return语句，不跑出异常的情况下当前try中变量此时对应的值，此后对变量做任何的修改，都不影响try中return的返回值； 若finally块中有return 语句，则返回try或catch中的返回语句忽略； 若finally块中抛出异常，则整个try、catch、finally块中抛出异常。 所以使用try、catch、finally语句块中需要注意的是: 尽量在try或者catch中使用return语句。 finally块中避免使用return语句，因为finally块中使用return语句会覆盖掉try、catch中的异常信息。 finally块中避免再次抛出异常，否则整个包含try语句块的方法回抛出异常，并且会消化掉try、catch块中的异常。 在平常的异常处理中，try-catch负责对异常的捕获处理，而finallly块则负责收尾工作。例如在程序开发中流的关闭，连接的关闭等等。 参考链接：1.java中关于try、catch、finally中的细节分析]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁与悲观锁]]></title>
    <url>%2F2016%2F06%2F12%2F%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[记得曾经面试的时候，面试官问到过这个问题，但是问题是关于Hibernate的，时隔快1年了，整理了下。 前言在数据库的锁机制中，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。 针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。 下面分别讨论一下悲观锁和乐观锁。 悲观锁 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 悲观锁(Pessimistic Locking)，顾名思义，对每次数据被外界的（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持悲观态度。每次外界在操作数据时，对数据进行锁定，直到当前操作完成以后释放锁，允许其他操作。在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle会自动应用行级锁： 123INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];SELECT … FOR UPDATE语句允许用户一次锁定多条记录进行更新使用COMMIT或ROLLBACK语句释放锁 Example: MySQL InnoDB中使用悲观锁 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 1set autocommit=0; 取消自动提交，当autocommit=1时候为立即提交 1.开始事务begin;/begin work;/start transaction; (三者选一就可以)2.查询出商品信息 1select status from t_goods where id=1 for update; 3.根据商品信息生成订单1insert into t_orders (id,goods_id) values (null,1); 4.修改商品status为21update t_goods set status=2; 5.提交事务1commit;/commit work; 表级锁又分为5类： 行共享 (ROW SHARE) – 禁止排他锁定表 行排他(ROW EXCLUSIVE) – 禁止使用排他锁和共享锁 共享锁(SHARE) - 锁定表，对记录只读不写，多个用户可以同时在同一个表上应用此锁 共享行排他(SHARE ROW EXCLUSIVE) – 比共享锁更多的限制，禁止使用共享锁及更高的锁 排他(EXCLUSIVE) – 限制最强的表锁，仅允许其他用户查询该表的行。禁止修改和锁定表。 优点与不足 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。 乐观锁 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。 它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。 乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 乐观锁(optimistic locking)，顾名思义，每次去拿数据的时候都认为别人不会修改，允许多个人同时修改同一文件。在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 使用版本号实现乐观锁 使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。 1.查询出商品信息 1select (status,status,version) from t_goods where id=#&#123;id&#125; 2.根据商品信息生成订单 3.修改商品status为2 123update t_goodsset status=2,version=version+1where id=#&#123;id&#125; and version=#&#123;version&#125;; 优点与不足 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。 两种锁各有优缺点，需要根据具体的场景进行响应的选择。乐观锁适用于常读少写的情况下，即冲突很少发生的时候，可以省去了锁的开销，减少数据库开销，加大系统的吞吐量。悲观锁则适用于常写少读的情况，确保操作的原子性。减少数据的冲突，保证数据的准确性。 参考：1.数据库锁机制2.深入理解乐观锁于悲观锁3.一分钟教你知道乐观锁和悲观锁的区别]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle-Sequence]]></title>
    <url>%2F2016%2F05%2F28%2FOracle-Sequence%2F</url>
    <content type="text"><![CDATA[最近在工作中频繁的用到了序列，以前没有注意过，现在抽个时间集中整理下。 在oracle中sequence就是序号，每次取的时候它会自动增加。sequence与表没有关系。 Create Sequence首先要有CREATE SEQUENCE或者CREATE ANY SEQUENCE权限。 创建语句如下： 123456CREATE SEQUENCE seqTest INCREMENT BY 1 -- 每次加几个 START WITH 1 -- 从1开始计数 NOMAXvalue -- 不设置最大值 NOCYCLE -- 一直累加，不循环 CACHE 10; --设置缓存cache个序列，如果系统down掉了或者其它情况将会导致序列不连续，也可以设置为---------NOCACHE Get Sequence定义好sequence后，你就可以用currVal，nextVal取得值。 NextVal：增加sequence的值，然后返回 增加后sequence值。 CurrVal：返回 sequence的当前值,必须执行nextval之后才能执行这个。 得到值语句如下：​ 1SELECT Sequence名称.CurrVal FROM DUAL; 如得到上边创建Sequence值的语句为： 1select seqtest.currval from dual 在Sql语句中可以使用sequence的地方： 1234- 不包含子查询、snapshot、VIEW的 SELECT 语句 - INSERT语句的子查询中 - INSERT语句的values中 - UPDATE 的 SET中 如在插入语句中 1insert into 表名(id,name)values(seqtest.Nextval,&apos;sequence 插入测试&apos;); 注：第一次NEXTVAL返回的是初始值；随后的NEXTVAL会自动增加你定义的INCREMENT BY值，然后返回增加后的值。 CURRVAL 总是返回当前SEQUENCE的值，但是在第一次NEXTVAL初始化之后才能使用CURRVAL，否则会出错。 一次NEXTVAL会增加一次 SEQUENCE的值，所以如果你在同一个语句里面使用多个NEXTVAL，其值就是不一样的。 如果指定CACHE值，ORACLE就可以预先在内存里面放置一些sequence，这样存取的快些。cache里面的取完后，oracle自动再取一组 到cache。 使用cache或许会跳号， 比如数据库突然不正常down掉（shutdown abort),cache中的sequence就会丢失. 所以可以在create sequence的时候用nocache防止这种情况。 Alter Sequence1拥有ALTER ANY SEQUENCE 权限才能改动sequence. 可以alter除start至以外的所有sequence参数.如果想要改变start值，必须 drop sequence 再 re-create。 例：alter sequence SEQTEST maxvalue 9999999; 1另： SEQUENCE_CACHE_ENTRIES参数，设置能同时被cache的sequence数目。 Drop Sequence1DROP SEQUENCE seqTest; Reset Sequence有时候需要重置序列，所以要曲线的调用存储过程重置序列。 12345678910111213141516create or Replace Procedure seq_Reset(v_seqname in varchar2) as n number(10); tsql varchar2(100);Begin tsql := &apos;Select &apos; || v_seqname || &apos;.nextval From dual&apos;; Execute Immediate tsql into n; --如果序列本身是初始状态则不进行数值计算 if n &lt;&gt; 1 then n := -(n-1); end if; tsql := &apos;Alter Sequence &apos; || v_seqname || &apos; Increment By &apos; || n; Execute Immediate tsql; tsql := &apos;Select &apos; || v_seqname || &apos;.nextval From dual&apos;; Execute Immediate tsql into n; tsql := &apos;Alter Sequence &apos; || v_seqname || &apos; Increment By 1&apos;; Execute Immediate tsql; End seq_Reset; Sample1234567create sequence SEQ_IDminvalue 1maxvalue 99999999start with 1increment by 1nocacheorder; 建解发器代码为： 12345678910111213create or replace trigger tri_test_id before insert on S_Depart --S_Depart 是表名 for each rowdeclare nextid number;begin IF :new.DepartId IS NULLor :new.DepartId=0 THEN --DepartId是列名 select SEQ_ID.nextval --SEQ_ID正是刚才创建的 into nextid from sys.dual; :new.DepartId:=nextid; end if;end tri_test_id; 上面的代码就可以实现自动递增的功能了。 123注 :new 代表 数据改变后的新值，相对应的有 :old 原值 := 代表 赋值 :nextid表示引用sqlplus中定义的变量 以上内容是在转载和总结的基础上写出来的，仅供参考。 转载网站： ORACLE SEQUENCE用法 参考文章： Oracle创建自增字段方法-ORACLE SEQUENCE的简单介绍]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom activate-power-mode插件安装]]></title>
    <url>%2F2015%2F12%2F21%2FAtom%2F</url>
    <content type="text"><![CDATA[两周前在微信公众号里看到关于对Atom编辑器中酷炫效果的展示，觉得很有意思，于是去尝试了一下这个酷炫的插件。 AtomAtom是Github开源的文本编辑器，这个编辑器完全是使用Web技术构建的(基于Node-Webkit)。Atom的强大可以与大名鼎鼎的Sublime Text相媲美。两者界面相差也不是很多，易于上手。 以下是一位知乎大神对其本质的解析： Sublime 是原生界面，脚本用的是 python；Atom 应该是基于 Chromium Embedded Framework，基本上就是个 web app，源码都是 CoffeeScript 写的，连界面都可以用 CSS 来自定义。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;知乎–尤雨溪 Atom安装目前Atom官网已经有了1.0版本.可以从它的官网上进行下载。 从网站图片就可以看出这款编辑器的精美，点击中间的红色按钮就下载就可以了。安装完成后启动界面如下图所示： 下载安装完成后，难处主要实在安装activate-power-mode的过程。这个过程很曲折。 插件下载首先要从官网下载插件：activate-power-mode进入页面后点击versions，会进入一个显示各个历史安装包的页面可以下载。选择适合的包进行下载。 具体的下载页面如下所示： 插件安装1.在安装好Atom后右键点击，打开文件位置。可以看到文件安装在C:\Users\Administrator\AppData\Local\atom\app-1.3.2下。 注意：（如果是安装的话，忽略这步，如果是解压的话，需要配置环境变量到path中，路径为 ：~\atom\app-1.3.2\resources\app\apm\bin,和JAVA_HOME类似）。2.将下载的zip包解压，放到C:\Users\Administrator\.atom\packages下。以管理员身份运行windowsDos命令窗口，进入到~/packages/activate-power-mode下，运行命令：1$ apm install 1$ apm install activate-power-mode 3.当两个命令都出现done的提示的时候，证明安装成功了。(借用CSDN的图) 在安装过程中可能会出现如下错误：网上搜索后，说是缺少依赖组件产生的。需要运行如下命令：ps：运行这条命需要安装Git客户端。1npm install easyimage 奇怪的是：我运行后还是会出现错误，但是我打开Atom编辑器已经可以使用了，希望哪位大神，弄清原理后说明一下。十分感谢！ 安装完之后重启，打开Atom，在新建文档时，不会出现效果。需要手动加载插件（通过快捷键ctrl+alt+o​打开），就可以看到酷炫效果了！最终的效果： 小技巧：去除屏幕抖动效果——shake。可能会有人觉得这个插件抖动的时候看起来很不舒服，晃眼。其实去掉这个效果很简单，在文件夹下1~\.atom\packages\activate-power-mode\lib 找到activate-power-mode.coffee文件，打开-&gt;找到如下图所示文件位置。将文件中的screenShake.enabled改为screenShake.disabled即可。 是不是看起来舒服多了呢？快开始你的编码旅程吧！部分内容转载自：1.Atom与markdown2.Github Atom 安装activate power mode炫酷插件超详细教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logo]]></title>
    <url>%2F2015%2F09%2F24%2FLogo%2F</url>
    <content type="text"><![CDATA[周末在家做的logo，略丑，凑合还可以用。后期有时间了再调整下。 目前做了三种尺寸，32 32，64 64，128 * 128 ，目前这三种格式基本够用，后期需要优化。 32*32 64*64 128*128]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>logo</tag>
      </tags>
  </entry>
</search>
